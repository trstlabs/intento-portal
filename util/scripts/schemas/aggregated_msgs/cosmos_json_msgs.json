{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.auth.v1beta1.Params",
          "additionalProperties": true,
          "description": "params defines the x/auth parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.auth.v1beta1.Params": {
      "properties": {
        "maxMemoCharacters": {
          "type": "string"
        },
        "txSigLimit": {
          "type": "string"
        },
        "txSizeCostPerByte": {
          "type": "string"
        },
        "sigVerifyCostEd25519": {
          "type": "string"
        },
        "sigVerifyCostSecp256k1": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the auth module."
    }
  }
}
{
  "$ref": "#/definitions/MsgExec",
  "definitions": {
    "MsgExec": {
      "properties": {
        "grantee": {
          "type": "string"
        },
        "msgs": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "binary",
                "binaryEncoding": "base64"
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "type": "array",
          "description": "Execute Msg. The x/authz will try to find a grant matching (msg.signers[0], grantee, MsgTypeURL(msg)) triple and validate it."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Exec",
      "description": "MsgExec attempts to execute the provided messages using authorizations granted to the grantee. Each message should have only one signer corresponding to the granter of the authorization."
    }
  }
}
{
  "$ref": "#/definitions/MsgGrant",
  "definitions": {
    "MsgGrant": {
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "grant": {
          "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
          "additionalProperties": true
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Grant",
      "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time."
    },
    "cosmos.authz.v1beta1.Grant": {
      "properties": {
        "authorization": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object"
        },
        "expiration": {
          "type": "string",
          "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
          "format": "date-time"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Grant",
      "description": "Grant gives permissions to execute the provide method with expiration time."
    }
  }
}
{
  "$ref": "#/definitions/MsgRevoke",
  "definitions": {
    "MsgRevoke": {
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "msgTypeUrl": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Revoke",
      "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee."
    }
  }
}
{
  "$ref": "#/definitions/MsgMultiSend",
  "definitions": {
    "MsgMultiSend": {
      "properties": {
        "inputs": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
          },
          "type": "array",
          "description": "Inputs, despite being `repeated`, only allows one sender input. This is checked in MsgMultiSend's ValidateBasic."
        },
        "outputs": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Multi Send",
      "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message."
    },
    "cosmos.bank.v1beta1.Input": {
      "properties": {
        "address": {
          "type": "string"
        },
        "coins": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Input",
      "description": "Input models transaction input."
    },
    "cosmos.bank.v1beta1.Output": {
      "properties": {
        "address": {
          "type": "string"
        },
        "coins": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Output",
      "description": "Output models transaction outputs."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgSend",
  "definitions": {
    "MsgSend": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Send",
      "description": "MsgSend represents a message to send coins from one account to another."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgSetSendEnabled",
  "definitions": {
    "MsgSetSendEnabled": {
      "properties": {
        "authority": {
          "type": "string"
        },
        "sendEnabled": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          },
          "type": "array",
          "description": "send_enabled is the list of entries to add or update."
        },
        "useDefaultFor": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "use_default_for is a list of denoms that should use the params.default_send_enabled value. Denoms listed here will have their SendEnabled entries deleted. If a denom is included that doesn't have a SendEnabled entry, it will be ignored."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Set Send Enabled",
      "description": "MsgSetSendEnabled is the Msg/SetSendEnabled request type. Only entries to add/update/delete need to be included. Existing SendEnabled entries that are not included in this message are left unchanged. Since: cosmos-sdk 0.47"
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Send Enabled",
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.bank.v1beta1.Params",
          "additionalProperties": true,
          "description": "params defines the x/bank parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.bank.v1beta1.Params": {
      "properties": {
        "sendEnabled": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          },
          "type": "array",
          "description": "Deprecated: Use of SendEnabled in params is deprecated. For genesis, use the newly added send_enabled field in the genesis object. Storage, lookup, and manipulation of this information is now in the keeper. As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
        },
        "defaultSendEnabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Send Enabled",
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
    }
  }
}
{
  "$ref": "#/definitions/MsgData",
  "definitions": {
    "MsgData": {
      "properties": {
        "msgType": {
          "type": "string"
        },
        "data": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Data",
      "description": "MsgData defines the data returned in a Result object during message execution."
    }
  }
}
{
  "$ref": "#/definitions/TxMsgData",
  "definitions": {
    "TxMsgData": {
      "properties": {
        "data": {
          "items": {
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.MsgData"
          },
          "type": "array",
          "description": "data field is deprecated and not populated."
        },
        "msgResponses": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "binary",
                "binaryEncoding": "base64"
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "type": "array",
          "description": "msg_responses contains the Msg handler responses packed into Anys. Since: cosmos-sdk 0.46"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Tx Msg Data",
      "description": "TxMsgData defines a list of MsgData. A transaction will have a MsgData object for each message."
    },
    "cosmos.base.abci.v1beta1.MsgData": {
      "properties": {
        "msgType": {
          "type": "string"
        },
        "data": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Data",
      "description": "MsgData defines the data returned in a Result object during message execution."
    }
  }
}
{
  "$ref": "#/definitions/MsgDescriptor",
  "definitions": {
    "MsgDescriptor": {
      "properties": {
        "msgTypeUrl": {
          "type": "string",
          "description": "msg_type_url contains the TypeURL of a sdk.Msg."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Descriptor",
      "description": "MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction"
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "constantFee": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": true,
          "description": "constant_fee defines the x/crisis parameter."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgVerifyInvariant",
  "definitions": {
    "MsgVerifyInvariant": {
      "properties": {
        "sender": {
          "type": "string",
          "description": "sender is the account address of private key to send coins to fee collector account."
        },
        "invariantModuleName": {
          "type": "string",
          "description": "name of the invariant module."
        },
        "invariantRoute": {
          "type": "string",
          "description": "invariant_route is the msg's invariant route."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Verify Invariant",
      "description": "MsgVerifyInvariant represents a message to verify a particular invariance."
    }
  }
}
{
  "$ref": "#/definitions/MsgCommunityPoolSpend",
  "definitions": {
    "MsgCommunityPoolSpend": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "recipient": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Community Pool Spend",
      "description": "MsgCommunityPoolSpend defines a message for sending tokens from the community pool to another account. This message is typically executed via a governance proposal with the governance module being the executing authority. Since: cosmos-sdk 0.47"
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgFundCommunityPool",
  "definitions": {
    "MsgFundCommunityPool": {
      "properties": {
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        },
        "depositor": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Fund Community Pool",
      "description": "MsgFundCommunityPool allows an account to directly fund the community pool."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgSetWithdrawAddress",
  "definitions": {
    "MsgSetWithdrawAddress": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "withdrawAddress": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Set Withdraw Address",
      "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation)."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.distribution.v1beta1.Params",
          "additionalProperties": true,
          "description": "params defines the x/distribution parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.distribution.v1beta1.Params": {
      "properties": {
        "communityTax": {
          "type": "string"
        },
        "baseProposerReward": {
          "type": "string",
          "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used in the x/distribution module's reward mechanism."
        },
        "bonusProposerReward": {
          "type": "string",
          "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used in the x/distribution module's reward mechanism."
        },
        "withdrawAddrEnabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Params",
      "description": "Params defines the set of params for the distribution module."
    }
  }
}
{
  "$ref": "#/definitions/MsgWithdrawDelegatorReward",
  "definitions": {
    "MsgWithdrawDelegatorReward": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Withdraw Delegator Reward",
      "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator."
    }
  }
}
{
  "$ref": "#/definitions/MsgWithdrawValidatorCommission",
  "definitions": {
    "MsgWithdrawValidatorCommission": {
      "properties": {
        "validatorAddress": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Withdraw Validator Commission",
      "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address."
    }
  }
}
{
  "$ref": "#/definitions/MsgSubmitEvidence",
  "definitions": {
    "MsgSubmitEvidence": {
      "properties": {
        "submitter": {
          "type": "string",
          "description": "submitter is the signer account address of evidence."
        },
        "evidence": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "evidence defines the evidence of misbehavior."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Submit Evidence",
      "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing."
    }
  }
}
{
  "$ref": "#/definitions/MsgGrantAllowance",
  "definitions": {
    "MsgGrantAllowance": {
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        },
        "allowance": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "allowance can be any of basic, periodic, allowed fee allowance."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Grant Allowance",
      "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter."
    }
  }
}
{
  "$ref": "#/definitions/MsgRevokeAllowance",
  "definitions": {
    "MsgRevokeAllowance": {
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Revoke Allowance",
      "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee."
    }
  }
}
{
  "$ref": "#/definitions/MsgDeposit",
  "definitions": {
    "MsgDeposit": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array",
          "description": "amount to be deposited by depositor."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Deposit",
      "description": "MsgDeposit defines a message to submit a deposit to an existing proposal."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgSubmitProposal",
  "definitions": {
    "MsgSubmitProposal": {
      "properties": {
        "content": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "content is the proposal's content."
        },
        "initialDeposit": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array",
          "description": "initial_deposit is the deposit value that must be paid at proposal submission."
        },
        "proposer": {
          "type": "string",
          "description": "proposer is the account address of the proposer."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Submit Proposal",
      "description": "MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary proposal Content."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgVote",
  "definitions": {
    "MsgVote": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            0,
            "VOTE_OPTION_YES",
            1,
            "VOTE_OPTION_ABSTAIN",
            2,
            "VOTE_OPTION_NO",
            3,
            "VOTE_OPTION_NO_WITH_VETO",
            4
          ],
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            }
          ],
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Vote",
      "description": "MsgVote defines a message to cast a vote."
    }
  }
}
{
  "$ref": "#/definitions/MsgVoteWeighted",
  "definitions": {
    "MsgVoteWeighted": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "options": {
          "items": {
            "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
          },
          "type": "array",
          "description": "options defines the weighted vote options."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Vote Weighted",
      "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43"
    },
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      "properties": {
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            0,
            "VOTE_OPTION_YES",
            1,
            "VOTE_OPTION_ABSTAIN",
            2,
            "VOTE_OPTION_NO",
            3,
            "VOTE_OPTION_NO_WITH_VETO",
            4
          ],
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            }
          ],
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Weighted Vote Option",
      "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43"
    }
  }
}
{
  "$ref": "#/definitions/MsgCreateGroup",
  "definitions": {
    "MsgCreateGroup": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "members": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "type": "array",
          "description": "members defines the group members."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata to attached to the group."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Groups",
      "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
{
  "$ref": "#/definitions/MsgCreateGroupPolicy",
  "definitions": {
    "MsgCreateGroupPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the group policy."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy specifies the group policy's decision policy."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Group Policies",
      "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgCreateGroupWithPolicy",
  "definitions": {
    "MsgCreateGroupWithPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group and group policy admin."
        },
        "members": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "type": "array",
          "description": "members defines the group members."
        },
        "groupMetadata": {
          "type": "string",
          "description": "group_metadata is any arbitrary metadata attached to the group."
        },
        "groupPolicyMetadata": {
          "type": "string",
          "description": "group_policy_metadata is any arbitrary metadata attached to the group policy."
        },
        "groupPolicyAsAdmin": {
          "type": "boolean",
          "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy specifies the group policy's decision policy."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Create Group With Policy",
      "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
{
  "$ref": "#/definitions/MsgExec",
  "definitions": {
    "MsgExec": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "executor": {
          "type": "string",
          "description": "executor is the account address used to execute the proposal."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Exec",
      "description": "MsgExec is the Msg/Exec request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgLeaveGroup",
  "definitions": {
    "MsgLeaveGroup": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the account address of the group member."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Leave Group",
      "description": "MsgLeaveGroup is the Msg/LeaveGroup request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgSubmitProposal",
  "definitions": {
    "MsgSubmitProposal": {
      "properties": {
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "proposers": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "proposers are the account addresses of the proposers. Proposers signatures will be counted as yes votes."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the proposal."
        },
        "messages": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "binary",
                "binaryEncoding": "base64"
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "type": "array",
          "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes."
        },
        "exec": {
          "enum": [
            "EXEC_UNSPECIFIED",
            0,
            "EXEC_TRY",
            1
          ],
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            }
          ],
          "title": "Proposals and Voting",
          "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote."
        },
        "title": {
          "type": "string",
          "description": "title is the title of the proposal. Since: cosmos-sdk 0.47"
        },
        "summary": {
          "type": "string",
          "description": "summary is the summary of the proposal. Since: cosmos-sdk 0.47"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Submit Proposal",
      "description": "MsgSubmitProposal is the Msg/SubmitProposal request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupAdmin",
  "definitions": {
    "MsgUpdateGroupAdmin": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the current account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "newAdmin": {
          "type": "string",
          "description": "new_admin is the group new admin account address."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Admin",
      "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupMembers",
  "definitions": {
    "MsgUpdateGroupMembers": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "memberUpdates": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "type": "array",
          "description": "member_updates is the list of members to update, set weight to 0 to remove a member."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Members",
      "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupMetadata",
  "definitions": {
    "MsgUpdateGroupMetadata": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is the updated group's metadata."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Metadata",
      "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin",
  "definitions": {
    "MsgUpdateGroupPolicyAdmin": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of the group policy."
        },
        "newAdmin": {
          "type": "string",
          "description": "new_admin is the new group policy admin."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Policy Admin",
      "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy",
  "definitions": {
    "MsgUpdateGroupPolicyDecisionPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy is the updated group policy's decision policy."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Policy Decision Policy",
      "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata",
  "definitions": {
    "MsgUpdateGroupPolicyMetadata": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is the group policy metadata to be updated."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Group Policy Metadata",
      "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgVote",
  "definitions": {
    "MsgVote": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter account address."
        },
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            0,
            "VOTE_OPTION_YES",
            1,
            "VOTE_OPTION_ABSTAIN",
            2,
            "VOTE_OPTION_NO",
            3,
            "VOTE_OPTION_NO_WITH_VETO",
            4
          ],
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            }
          ],
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given proposal."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the vote."
        },
        "exec": {
          "enum": [
            "EXEC_UNSPECIFIED",
            0,
            "EXEC_TRY",
            1
          ],
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            }
          ],
          "title": "Proposals and Voting",
          "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Vote",
      "description": "MsgVote is the Msg/Vote request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgWithdrawProposal",
  "definitions": {
    "MsgWithdrawProposal": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "address": {
          "type": "string",
          "description": "address is the admin of the group policy or one of the proposer of the proposal."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Withdraw Proposal",
      "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type."
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.mint.v1beta1.Params",
          "additionalProperties": true,
          "description": "params defines the x/mint parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.mint.v1beta1.Params": {
      "properties": {
        "mintDenom": {
          "type": "string",
          "description": "type of coin to mint"
        },
        "inflationRateChange": {
          "type": "string",
          "description": "maximum annual change in inflation rate"
        },
        "inflationMax": {
          "type": "string",
          "description": "maximum inflation rate"
        },
        "inflationMin": {
          "type": "string",
          "description": "minimum inflation rate"
        },
        "goalBonded": {
          "type": "string",
          "description": "goal of percent bonded atoms"
        },
        "blocksPerYear": {
          "type": "string",
          "description": "expected blocks per year"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the x/mint module."
    }
  }
}
{
  "$ref": "#/definitions/MsgSend",
  "definitions": {
    "MsgSend": {
      "properties": {
        "classId": {
          "type": "string",
          "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721"
        },
        "id": {
          "type": "string",
          "description": "id defines the unique identification of nft"
        },
        "sender": {
          "type": "string",
          "description": "sender is the address of the owner of nft"
        },
        "receiver": {
          "type": "string",
          "description": "receiver is the receiver address of nft"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Send",
      "description": "MsgSend represents a message to send a nft from one account to another account."
    }
  }
}
{
  "$ref": "#/definitions/MsgUnjail",
  "definitions": {
    "MsgUnjail": {
      "properties": {
        "validatorAddr": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Unjail",
      "description": "MsgUnjail defines the Msg/Unjail request type"
    }
  }
}
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.slashing.v1beta1.Params",
          "additionalProperties": true,
          "description": "params defines the x/slashing parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type. Since: cosmos-sdk 0.47"
    },
    "cosmos.slashing.v1beta1.Params": {
      "properties": {
        "signedBlocksWindow": {
          "type": "string"
        },
        "minSignedPerWindow": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        },
        "downtimeJailDuration": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "format": "regex"
        },
        "slashFractionDoubleSign": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        },
        "slashFractionDowntime": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Params",
      "description": "Params represents the parameters used for by the slashing module."
    }
  }
}
{
  "$ref": "#/definitions/MsgCancelUpgrade",
  "definitions": {
    "MsgCancelUpgrade": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Cancel Upgrade",
      "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46"
    }
  }
}
{
  "$ref": "#/definitions/MsgSoftwareUpgrade",
  "definitions": {
    "MsgSoftwareUpgrade": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "plan": {
          "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
          "additionalProperties": true,
          "description": "plan is the upgrade plan."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Software Upgrade",
      "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46"
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit."
        },
        "time": {
          "type": "string",
          "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
          "format": "date-time"
        },
        "height": {
          "type": "string",
          "description": "The height at which the upgrade must be performed."
        },
        "info": {
          "type": "string",
          "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to"
        },
        "upgradedClientState": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "description": "Must be a valid serialized protocol buffer of the above specified type.",
              "format": "binary",
              "binaryEncoding": "base64"
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown."
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Plan",
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    }
  }
}
{
  "$ref": "#/definitions/MsgCreatePeriodicVestingAccount",
  "definitions": {
    "MsgCreatePeriodicVestingAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "startTime": {
          "type": "string",
          "description": "start of vesting as unix time (in seconds)."
        },
        "vestingPeriods": {
          "items": {
            "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Create Periodic Vesting Account",
      "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46"
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    },
    "cosmos.vesting.v1beta1.Period": {
      "properties": {
        "length": {
          "type": "string",
          "description": "Period duration in seconds."
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Period",
      "description": "Period defines a length of time and amount of coins that will vest."
    }
  }
}
{
  "$ref": "#/definitions/MsgCreatePermanentLockedAccount",
  "definitions": {
    "MsgCreatePermanentLockedAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Create Permanent Locked Account",
      "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46"
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
{
  "$ref": "#/definitions/MsgCreateVestingAccount",
  "definitions": {
    "MsgCreateVestingAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "type": "array"
        },
        "endTime": {
          "type": "string",
          "description": "end of vesting as unix time (in seconds)."
        },
        "delayed": {
          "type": "boolean"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Msg Create Vesting Account",
      "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": true,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
