[
{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.auth.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/auth parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.auth.v1beta1.Params": {
      "properties": {
        "maxMemoCharacters": {
          "type": "string"
        },
        "txSigLimit": {
          "type": "string"
        },
        "txSizeCostPerByte": {
          "type": "string"
        },
        "sigVerifyCostEd25519": {
          "type": "string"
        },
        "sigVerifyCostSecp256k1": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the auth module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgExec",
  "definitions": {
    "MsgExec": {
      "properties": {
        "grantee": {
          "type": "string"
        },
        "msgs": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "Execute Msg. The x/authz will try to find a grant matching (msg.signers[0], grantee, MsgTypeURL(msg)) triple and validate it."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Exec",
      "description": "MsgExec attempts to execute the provided messages using authorizations granted to the grantee. Each message should have only one signer corresponding to the granter of the authorization."
    }
  }
}
,{
  "$ref": "#/definitions/MsgGrant",
  "definitions": {
    "MsgGrant": {
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "grant": {
          "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Grant",
      "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time."
    },
    "cosmos.authz.v1beta1.Grant": {
      "properties": {
        "authorization": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object"
        },
        "expiration": {
          "type": "string",
          "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
          "format": "date-time"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Grant",
      "description": "Grant gives permissions to execute the provide method with expiration time."
    }
  }
}
,{
  "$ref": "#/definitions/MsgRevoke",
  "definitions": {
    "MsgRevoke": {
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "msgTypeUrl": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Revoke",
      "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee."
    }
  }
}
,{
  "$ref": "#/definitions/MsgMultiSend",
  "definitions": {
    "MsgMultiSend": {
      "properties": {
        "inputs": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "Inputs, despite being `repeated`, only allows one sender input. This is checked in MsgMultiSend's ValidateBasic."
        },
        "outputs": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Multi Send",
      "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message."
    },
    "cosmos.bank.v1beta1.Input": {
      "properties": {
        "address": {
          "type": "string"
        },
        "coins": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Input",
      "description": "Input models transaction input."
    },
    "cosmos.bank.v1beta1.Output": {
      "properties": {
        "address": {
          "type": "string"
        },
        "coins": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Output",
      "description": "Output models transaction outputs."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSend",
  "definitions": {
    "MsgSend": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Send",
      "description": "MsgSend represents a message to send coins from one account to another."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSetSendEnabled",
  "definitions": {
    "MsgSetSendEnabled": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module."
        },
        "sendEnabled": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "send_enabled is the list of entries to add or update."
        },
        "useDefaultFor": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "use_default_for is a list of denoms that should use the params.default_send_enabled value. Denoms listed here will have their SendEnabled entries deleted. If a denom is included that doesn't have a SendEnabled entry, it will be ignored."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Set Send Enabled",
      "description": "MsgSetSendEnabled is the Msg/SetSendEnabled request type. Only entries to add/update/delete need to be included. Existing SendEnabled entries that are not included in this message are left unchanged."
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Send Enabled",
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.bank.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/bank parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.bank.v1beta1.Params": {
      "properties": {
        "sendEnabled": {
          "items": {
            "$ref": "#/definitions/cosmos.bank.v1beta1.SendEnabled"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "Deprecated: Use of SendEnabled in params is deprecated. For genesis, use the newly added send_enabled field in the genesis object. Storage, lookup, and manipulation of this information is now in the keeper. As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
        },
        "defaultSendEnabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Send Enabled",
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
    }
  }
}
,{
  "$ref": "#/definitions/MsgData",
  "definitions": {
    "MsgData": {
      "properties": {
        "msgType": {
          "type": "string"
        },
        "data": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Data",
      "description": "MsgData defines the data returned in a Result object during message execution."
    }
  }
}
,{
  "$ref": "#/definitions/TxMsgData",
  "definitions": {
    "TxMsgData": {
      "properties": {
        "data": {
          "items": {
            "$ref": "#/definitions/cosmos.base.abci.v1beta1.MsgData"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "data field is deprecated and not populated."
        },
        "msgResponses": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "msg_responses contains the Msg handler responses packed into Anys."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Tx Msg Data",
      "description": "TxMsgData defines a list of MsgData. A transaction will have a MsgData object for each message."
    },
    "cosmos.base.abci.v1beta1.MsgData": {
      "properties": {
        "msgType": {
          "type": "string"
        },
        "data": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Data",
      "description": "MsgData defines the data returned in a Result object during message execution."
    }
  }
}
,{
  "$ref": "#/definitions/MsgDescriptor",
  "definitions": {
    "MsgDescriptor": {
      "properties": {
        "msgTypeUrl": {
          "type": "string",
          "description": "msg_type_url contains the TypeURL of a sdk.Msg."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Descriptor",
      "description": "MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction"
    }
  }
}
,{
  "$ref": "#/definitions/MsgLoadTest",
  "definitions": {
    "MsgLoadTest": {
      "properties": {
        "caller": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        },
        "ops": {
          "items": {
            "$ref": "#/definitions/cosmos.benchmark.v1.Op"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Load Test",
      "description": "MsgLoadTestOps defines a message containing a sequence of load test operations."
    },
    "cosmos.benchmark.v1.Op": {
      "properties": {
        "seed": {
          "type": "string"
        },
        "actor": {
          "type": "string"
        },
        "keyLength": {
          "type": "string"
        },
        "valueLength": {
          "type": "string"
        },
        "iterations": {
          "type": "integer"
        },
        "delete": {
          "type": "boolean"
        },
        "exists": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Op",
      "description": "Op is a message describing a benchmark operation."
    }
  }
}
,{
  "$ref": "#/definitions/MsgAuthorizeCircuitBreaker",
  "definitions": {
    "MsgAuthorizeCircuitBreaker": {
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the granter of the circuit breaker permissions and must have LEVEL_SUPER_ADMIN."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the account authorized with the provided permissions."
        },
        "permissions": {
          "$ref": "#/definitions/cosmos.circuit.v1.Permissions",
          "additionalProperties": false,
          "description": "permissions are the circuit breaker permissions that the grantee receives. These will overwrite any existing permissions. LEVEL_NONE_UNSPECIFIED can be specified to revoke all permissions."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Authorize Circuit Breaker",
      "description": "MsgAuthorizeCircuitBreaker defines the Msg/AuthorizeCircuitBreaker request type."
    },
    "cosmos.circuit.v1.Permissions": {
      "properties": {
        "level": {
          "enum": [
            "LEVEL_NONE_UNSPECIFIED",
            "LEVEL_SOME_MSGS",
            "LEVEL_ALL_MSGS",
            "LEVEL_SUPER_ADMIN"
          ],
          "type": "string",
          "title": "Level",
          "description": "Level is the permission level."
        },
        "limitTypeUrls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "limit_type_urls is used with LEVEL_SOME_MSGS to limit the lists of Msg type URLs that the account can trip. It is an error to use limit_type_urls with a level other than LEVEL_SOME_MSGS."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Permissions",
      "description": "Permissions are the permissions that an account has to trip or reset the circuit breaker."
    }
  }
}
,{
  "$ref": "#/definitions/MsgResetCircuitBreaker",
  "definitions": {
    "MsgResetCircuitBreaker": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the account authorized to trip or reset the circuit breaker."
        },
        "msgTypeUrls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "msg_type_urls specifies a list of Msg type URLs to resume processing. If it is left empty all Msg processing for type URLs that the account is authorized to trip will resume."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Reset Circuit Breaker",
      "description": "MsgResetCircuitBreaker defines the Msg/ResetCircuitBreaker request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgTripCircuitBreaker",
  "definitions": {
    "MsgTripCircuitBreaker": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the account authorized to trip the circuit breaker."
        },
        "msgTypeUrls": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "msg_type_urls specifies a list of type URLs to immediately stop processing. IF IT IS LEFT EMPTY, ALL MSG PROCESSING WILL STOP IMMEDIATELY. This value is validated against the authority's permissions and if the authority does not have permissions to trip the specified msg type URLs (or all URLs), the operation will fail."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Trip Circuit Breaker",
      "description": "MsgTripCircuitBreaker defines the Msg/TripCircuitBreaker request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "block": {
          "$ref": "#/definitions/tendermint.types.BlockParams",
          "additionalProperties": false,
          "description": "params defines the x/consensus parameters to update. VersionsParams is not included in this Msg because it is tracked separarately in x/upgrade. NOTE: All parameters must be supplied."
        },
        "evidence": {
          "$ref": "#/definitions/tendermint.types.EvidenceParams",
          "additionalProperties": false
        },
        "validator": {
          "$ref": "#/definitions/tendermint.types.ValidatorParams",
          "additionalProperties": false
        },
        "abci": {
          "$ref": "#/definitions/tendermint.types.ABCIParams",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "tendermint.types.ABCIParams": {
      "properties": {
        "voteExtensionsEnableHeight": {
          "type": "string",
          "description": "vote_extensions_enable_height configures the first height during which vote extensions will be enabled. During this specified height, and for all subsequent heights, precommit messages that do not contain valid extension data will be considered invalid. Prior to this height, vote extensions will not be used or accepted by validators on the network. Once enabled, vote extensions will be created by the application in ExtendVote, passed to the application for validation in VerifyVoteExtension and given to the application to use when proposing a block during PrepareProposal."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "ABCI Params",
      "description": "ABCIParams configure functionality specific to the Application Blockchain Interface."
    },
    "tendermint.types.BlockParams": {
      "properties": {
        "maxBytes": {
          "type": "string",
          "description": "Max block size, in bytes. Note: must be greater than 0"
        },
        "maxGas": {
          "type": "string",
          "description": "Max gas per block. Note: must be greater or equal to -1"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Block Params",
      "description": "BlockParams contains limits on the block size."
    },
    "tendermint.types.EvidenceParams": {
      "properties": {
        "maxAgeNumBlocks": {
          "type": "string",
          "description": "Max age of evidence, in blocks. The basic formula for calculating this is: MaxAgeDuration / {average block time}."
        },
        "maxAgeDuration": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "description": "Max age of evidence, in time. It should correspond with an app's \"unbonding period\" or other similar mechanism for handling [Nothing-At-Stake attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).",
          "format": "regex"
        },
        "maxBytes": {
          "type": "string",
          "description": "This sets the maximum size of total evidence in bytes that can be committed in a single block. and should fall comfortably under the max block bytes. Default is 1048576 or 1MB"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Evidence Params",
      "description": "EvidenceParams determine how we handle evidence of malfeasance."
    },
    "tendermint.types.ValidatorParams": {
      "properties": {
        "pubKeyTypes": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Validator Params",
      "description": "ValidatorParams restrict the public key types validators can use. NOTE: uses ABCI pubkey naming, not Amino names."
    }
  }
}
,{
  "$ref": "#/definitions/MsgIncreaseCounter",
  "definitions": {
    "MsgIncreaseCounter": {
      "properties": {
        "signer": {
          "type": "string",
          "description": "signer is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "count": {
          "type": "string",
          "description": "count is the number of times to increment the counter."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Increase Counter",
      "description": "MsgIncreaseCounter defines a count Msg service counter."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "constantFee": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false,
          "description": "constant_fee defines the x/crisis parameter."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVerifyInvariant",
  "definitions": {
    "MsgVerifyInvariant": {
      "properties": {
        "sender": {
          "type": "string",
          "description": "sender is the account address of private key to send coins to fee collector account."
        },
        "invariantModuleName": {
          "type": "string",
          "description": "name of the invariant module."
        },
        "invariantRoute": {
          "type": "string",
          "description": "invariant_route is the msg's invariant route."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Verify Invariant",
      "description": "MsgVerifyInvariant represents a message to verify a particular invariance."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCommunityPoolSpend",
  "definitions": {
    "MsgCommunityPoolSpend": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "recipient": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Community Pool Spend",
      "description": "MsgCommunityPoolSpend defines a message for sending tokens from the community pool to another account. This message is typically executed via a governance proposal with the governance module being the executing authority."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgDepositValidatorRewardsPool",
  "definitions": {
    "MsgDepositValidatorRewardsPool": {
      "properties": {
        "depositor": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Deposit Validator Rewards Pool",
      "description": "DepositValidatorRewardsPool defines the request structure to provide additional rewards to delegators from a specific validator."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgFundCommunityPool",
  "definitions": {
    "MsgFundCommunityPool": {
      "properties": {
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        },
        "depositor": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Fund Community Pool",
      "description": "MsgFundCommunityPool allows an account to directly fund the community pool."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSetWithdrawAddress",
  "definitions": {
    "MsgSetWithdrawAddress": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "withdrawAddress": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Set Withdraw Address",
      "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation)."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.distribution.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/distribution parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.distribution.v1beta1.Params": {
      "properties": {
        "communityTax": {
          "type": "string"
        },
        "baseProposerReward": {
          "type": "string",
          "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used in the x/distribution module's reward mechanism."
        },
        "bonusProposerReward": {
          "type": "string",
          "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used in the x/distribution module's reward mechanism."
        },
        "withdrawAddrEnabled": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the set of params for the distribution module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgWithdrawDelegatorReward",
  "definitions": {
    "MsgWithdrawDelegatorReward": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Withdraw Delegator Reward",
      "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator."
    }
  }
}
,{
  "$ref": "#/definitions/MsgWithdrawValidatorCommission",
  "definitions": {
    "MsgWithdrawValidatorCommission": {
      "properties": {
        "validatorAddress": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Withdraw Validator Commission",
      "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSubmitEvidence",
  "definitions": {
    "MsgSubmitEvidence": {
      "properties": {
        "submitter": {
          "type": "string",
          "description": "submitter is the signer account address of evidence."
        },
        "evidence": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "evidence defines the evidence of misbehavior."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Submit Evidence",
      "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing."
    }
  }
}
,{
  "$ref": "#/definitions/AllowedMsgAllowance",
  "definitions": {
    "AllowedMsgAllowance": {
      "properties": {
        "allowance": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "allowance can be any of basic and periodic fee allowance."
        },
        "allowedMessages": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "allowed_messages are the messages for which the grantee has the access."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Allowed Msg Allowance",
      "description": "AllowedMsgAllowance creates allowance only for specified message types."
    }
  }
}
,{
  "$ref": "#/definitions/MsgGrantAllowance",
  "definitions": {
    "MsgGrantAllowance": {
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        },
        "allowance": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "allowance can be any of basic, periodic, allowed fee allowance."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Grant Allowance",
      "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter."
    }
  }
}
,{
  "$ref": "#/definitions/MsgPruneAllowances",
  "definitions": {
    "MsgPruneAllowances": {
      "properties": {
        "pruner": {
          "type": "string",
          "description": "pruner is the address of the user pruning expired allowances."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Prune Allowances",
      "description": "MsgPruneAllowances prunes expired fee allowances."
    }
  }
}
,{
  "$ref": "#/definitions/MsgRevokeAllowance",
  "definitions": {
    "MsgRevokeAllowance": {
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Revoke Allowance",
      "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee."
    }
  }
}
,{
  "$ref": "#/definitions/MsgDeposit",
  "definitions": {
    "MsgDeposit": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "amount to be deposited by depositor."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Deposit",
      "description": "MsgDeposit defines a message to submit a deposit to an existing proposal."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSubmitProposal",
  "definitions": {
    "MsgSubmitProposal": {
      "properties": {
        "content": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "content is the proposal's content."
        },
        "initialDeposit": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "initial_deposit is the deposit value that must be paid at proposal submission."
        },
        "proposer": {
          "type": "string",
          "description": "proposer is the account address of the proposer."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Submit Proposal",
      "description": "MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary proposal Content."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVote",
  "definitions": {
    "MsgVote": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "type": "string",
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Vote",
      "description": "MsgVote defines a message to cast a vote."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVoteWeighted",
  "definitions": {
    "MsgVoteWeighted": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "options": {
          "items": {
            "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "options defines the weighted vote options."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Vote Weighted",
      "description": "MsgVoteWeighted defines a message to cast a vote."
    },
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      "properties": {
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "type": "string",
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Weighted Vote Option",
      "description": "WeightedVoteOption defines a unit of vote for vote split."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCancelProposal",
  "definitions": {
    "MsgCancelProposal": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "proposer": {
          "type": "string",
          "description": "proposer is the account address of the proposer."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Cancel Proposal",
      "description": "MsgCancelProposal is the Msg/CancelProposal request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgDeposit",
  "definitions": {
    "MsgDeposit": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "amount to be deposited by depositor."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Deposit",
      "description": "MsgDeposit defines a message to submit a deposit to an existing proposal."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgExecLegacyContent",
  "definitions": {
    "MsgExecLegacyContent": {
      "properties": {
        "content": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "content is the proposal's content."
        },
        "authority": {
          "type": "string",
          "description": "authority must be the gov module address."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Exec Legacy Content",
      "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSubmitProposal",
  "definitions": {
    "MsgSubmitProposal": {
      "properties": {
        "messages": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "messages are the arbitrary messages to be executed if proposal passes."
        },
        "initialDeposit": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "initial_deposit is the deposit value that must be paid at proposal submission."
        },
        "proposer": {
          "type": "string",
          "description": "proposer is the account address of the proposer."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the proposal."
        },
        "title": {
          "type": "string",
          "description": "title is the title of the proposal."
        },
        "summary": {
          "type": "string",
          "description": "summary is the summary of the proposal"
        },
        "expedited": {
          "type": "boolean",
          "description": "expedited defines if the proposal is expedited or not"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Submit Proposal",
      "description": "MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary proposal Content."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.gov.v1.Params",
          "additionalProperties": false,
          "description": "params defines the x/gov parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    },
    "cosmos.gov.v1.Params": {
      "properties": {
        "minDeposit": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "maxDepositPeriod": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2 months.",
          "format": "regex"
        },
        "votingPeriod": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "description": "Duration of the voting period.",
          "format": "regex"
        },
        "quorum": {
          "type": "string",
          "description": "Minimum percentage of total stake needed to vote for a result to be  considered valid."
        },
        "threshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "vetoThreshold": {
          "type": "string",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3."
        },
        "minInitialDepositRatio": {
          "type": "string",
          "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
        },
        "proposalCancelRatio": {
          "type": "string",
          "description": "The cancel ratio which will not be returned back to the depositors when a proposal is cancelled."
        },
        "proposalCancelDest": {
          "type": "string",
          "description": "The address which will receive (proposal_cancel_ratio * deposit) proposal deposits. If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned."
        },
        "expeditedVotingPeriod": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "description": "Duration of the voting period of an expedited proposal.",
          "format": "regex"
        },
        "expeditedThreshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.67."
        },
        "expeditedMinDeposit": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "Minimum expedited deposit for a proposal to enter voting period."
        },
        "burnVoteQuorum": {
          "type": "boolean",
          "description": "burn deposits if a proposal does not meet quorum"
        },
        "burnProposalDepositPrevote": {
          "type": "boolean",
          "description": "burn deposits if the proposal does not enter voting period"
        },
        "burnVoteVeto": {
          "type": "boolean",
          "description": "burn deposits if quorum with vote type no_veto is met"
        },
        "minDepositRatio": {
          "type": "string",
          "description": "The ratio representing the proportion of the deposit value minimum that must be met when making a deposit. Default value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be required."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the x/gov module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVote",
  "definitions": {
    "MsgVote": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "type": "string",
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the Vote."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Vote",
      "description": "MsgVote defines a message to cast a vote."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVoteWeighted",
  "definitions": {
    "MsgVoteWeighted": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address for the proposal."
        },
        "options": {
          "items": {
            "$ref": "#/definitions/cosmos.gov.v1.WeightedVoteOption"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "options defines the weighted vote options."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the VoteWeighted."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Vote Weighted",
      "description": "MsgVoteWeighted defines a message to cast a vote."
    },
    "cosmos.gov.v1.WeightedVoteOption": {
      "properties": {
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "type": "string",
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal."
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Weighted Vote Option",
      "description": "WeightedVoteOption defines a unit of vote for vote split."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateGroup",
  "definitions": {
    "MsgCreateGroup": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "members": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "members defines the group members."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata to attached to the group."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Groups",
      "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateGroupPolicy",
  "definitions": {
    "MsgCreateGroupPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the group policy."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy specifies the group policy's decision policy."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Group Policies",
      "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateGroupWithPolicy",
  "definitions": {
    "MsgCreateGroupWithPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group and group policy admin."
        },
        "members": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "members defines the group members."
        },
        "groupMetadata": {
          "type": "string",
          "description": "group_metadata is any arbitrary metadata attached to the group."
        },
        "groupPolicyMetadata": {
          "type": "string",
          "description": "group_policy_metadata is any arbitrary metadata attached to the group policy."
        },
        "groupPolicyAsAdmin": {
          "type": "boolean",
          "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy specifies the group policy's decision policy."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Group With Policy",
      "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
,{
  "$ref": "#/definitions/MsgExec",
  "definitions": {
    "MsgExec": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "executor": {
          "type": "string",
          "description": "executor is the account address used to execute the proposal."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Exec",
      "description": "MsgExec is the Msg/Exec request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgLeaveGroup",
  "definitions": {
    "MsgLeaveGroup": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the account address of the group member."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Leave Group",
      "description": "MsgLeaveGroup is the Msg/LeaveGroup request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSubmitProposal",
  "definitions": {
    "MsgSubmitProposal": {
      "properties": {
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "proposers": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "proposers are the account addresses of the proposers. Proposers signatures will be counted as yes votes."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the proposal."
        },
        "messages": {
          "items": {
            "properties": {
              "typeUrl": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
              }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Any",
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes."
        },
        "exec": {
          "enum": [
            "EXEC_UNSPECIFIED",
            "EXEC_TRY"
          ],
          "type": "string",
          "title": "Proposals and Voting",
          "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote."
        },
        "title": {
          "type": "string",
          "description": "title is the title of the proposal."
        },
        "summary": {
          "type": "string",
          "description": "summary is the summary of the proposal."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Submit Proposal",
      "description": "MsgSubmitProposal is the Msg/SubmitProposal request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupAdmin",
  "definitions": {
    "MsgUpdateGroupAdmin": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the current account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "newAdmin": {
          "type": "string",
          "description": "new_admin is the group new admin account address."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Admin",
      "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupMembers",
  "definitions": {
    "MsgUpdateGroupMembers": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "memberUpdates": {
          "items": {
            "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
          },
          "additionalProperties": false,
          "type": "array",
          "description": "member_updates is the list of members to update, set weight to 0 to remove a member."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Members",
      "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type."
    },
    "cosmos.group.v1.MemberRequest": {
      "properties": {
        "address": {
          "type": "string",
          "description": "address is the member's account address."
        },
        "weight": {
          "type": "string",
          "description": "weight is the member's voting weight that should be greater than 0."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the member."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Member Request",
      "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupMetadata",
  "definitions": {
    "MsgUpdateGroupMetadata": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupId": {
          "type": "string",
          "description": "group_id is the unique ID of the group."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is the updated group's metadata."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Metadata",
      "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin",
  "definitions": {
    "MsgUpdateGroupPolicyAdmin": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of the group policy."
        },
        "newAdmin": {
          "type": "string",
          "description": "new_admin is the new group policy admin."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Policy Admin",
      "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy",
  "definitions": {
    "MsgUpdateGroupPolicyDecisionPolicy": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "decisionPolicy": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "decision_policy is the updated group policy's decision policy."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Policy Decision Policy",
      "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata",
  "definitions": {
    "MsgUpdateGroupPolicyMetadata": {
      "properties": {
        "admin": {
          "type": "string",
          "description": "admin is the account address of the group admin."
        },
        "groupPolicyAddress": {
          "type": "string",
          "description": "group_policy_address is the account address of group policy."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is the group policy metadata to be updated."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Group Policy Metadata",
      "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgVote",
  "definitions": {
    "MsgVote": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter account address."
        },
        "option": {
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "type": "string",
          "title": "Vote Option",
          "description": "VoteOption enumerates the valid vote options for a given proposal."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the vote."
        },
        "exec": {
          "enum": [
            "EXEC_UNSPECIFIED",
            "EXEC_TRY"
          ],
          "type": "string",
          "title": "Proposals and Voting",
          "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Vote",
      "description": "MsgVote is the Msg/Vote request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgWithdrawProposal",
  "definitions": {
    "MsgWithdrawProposal": {
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "proposal is the unique ID of the proposal."
        },
        "address": {
          "type": "string",
          "description": "address is the admin of the group policy or one of the proposer of the proposal."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Withdraw Proposal",
      "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.mint.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/mint parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.mint.v1beta1.Params": {
      "properties": {
        "mintDenom": {
          "type": "string",
          "description": "type of coin to mint"
        },
        "inflationRateChange": {
          "type": "string",
          "description": "maximum annual change in inflation rate"
        },
        "inflationMax": {
          "type": "string",
          "description": "maximum inflation rate"
        },
        "inflationMin": {
          "type": "string",
          "description": "minimum inflation rate"
        },
        "goalBonded": {
          "type": "string",
          "description": "goal of percent bonded atoms"
        },
        "blocksPerYear": {
          "type": "string",
          "description": "expected blocks per year"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the x/mint module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSend",
  "definitions": {
    "MsgSend": {
      "properties": {
        "classId": {
          "type": "string",
          "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721"
        },
        "id": {
          "type": "string",
          "description": "id defines the unique identification of nft"
        },
        "sender": {
          "type": "string",
          "description": "sender is the address of the owner of nft"
        },
        "receiver": {
          "type": "string",
          "description": "receiver is the receiver address of nft"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Send",
      "description": "MsgSend represents a message to send a nft from one account to another account."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCancelContinuousFund",
  "definitions": {
    "MsgCancelContinuousFund": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "Authority is the account address of authority."
        },
        "recipient": {
          "type": "string",
          "description": "Recipient is the account address string of the recipient whose funds are to be cancelled."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Cancel Continuous Fund",
      "description": "MsgCancelContinuousFund defines a message to cancel continuous funds for a specific recipient."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCommunityPoolSpend",
  "definitions": {
    "MsgCommunityPoolSpend": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "Authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "recipient": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Community Pool Spend",
      "description": "MsgCommunityPoolSpend defines a message for sending tokens from the community pool to another account. This message is typically executed via a governance proposal with the governance module being the executing authority."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateContinuousFund",
  "definitions": {
    "MsgCreateContinuousFund": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "Authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "recipient": {
          "type": "string",
          "description": "Recipient address of the account receiving funds."
        },
        "percentage": {
          "type": "string",
          "description": "Percentage is the percentage of funds to be allocated from Community pool."
        },
        "expiry": {
          "type": "string",
          "description": "Optional, if expiry is set, removes the state object when expired.",
          "format": "date-time"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Continuous Fund",
      "description": "MsgCreateContinuousFund defines a message for adding continuous funds."
    }
  }
}
,{
  "$ref": "#/definitions/MsgFundCommunityPool",
  "definitions": {
    "MsgFundCommunityPool": {
      "properties": {
        "depositor": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Fund Community Pool",
      "description": "MsgFundCommunityPool allows an account to directly fund the community pool."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.protocolpool.v1.Params",
          "additionalProperties": false,
          "description": "params defines the x/protocolpool parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.protocolpool.v1.Params": {
      "properties": {
        "enabledDistributionDenoms": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "EnabledDistributionDenoms lists the denoms that are allowed to be distributed. This is to avoid spending time distributing undesired tokens to continuous funds and budgets."
        },
        "distributionFrequency": {
          "type": "string",
          "description": "DistributionFrequency is the frequency (in terms of blocks) that funds are distributed out from the x/protocolpool module."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the protocolpool module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUnjail",
  "definitions": {
    "MsgUnjail": {
      "properties": {
        "validatorAddr": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Unjail",
      "description": "MsgUnjail defines the Msg/Unjail request type"
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.slashing.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/slashing parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.slashing.v1beta1.Params": {
      "properties": {
        "signedBlocksWindow": {
          "type": "string"
        },
        "minSignedPerWindow": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        },
        "downtimeJailDuration": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "format": "regex"
        },
        "slashFractionDoubleSign": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        },
        "slashFractionDowntime": {
          "type": "string",
          "format": "binary",
          "binaryEncoding": "base64"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params represents the parameters used for by the slashing module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgBeginRedelegate",
  "definitions": {
    "MsgBeginRedelegate": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorSrcAddress": {
          "type": "string"
        },
        "validatorDstAddress": {
          "type": "string"
        },
        "amount": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Begin Redelegate",
      "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCancelUnbondingDelegation",
  "definitions": {
    "MsgCancelUnbondingDelegation": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        },
        "amount": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false,
          "description": "amount is always less than or equal to unbonding delegation entry balance"
        },
        "creationHeight": {
          "type": "string",
          "description": "creation_height is the height which the unbonding took place."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Cancel Unbonding Delegation",
      "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator"
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateValidator",
  "definitions": {
    "MsgCreateValidator": {
      "properties": {
        "description": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
          "additionalProperties": false
        },
        "commission": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
          "additionalProperties": false
        },
        "minSelfDelegation": {
          "type": "string"
        },
        "delegatorAddress": {
          "type": "string",
          "description": "Deprecated: Use of Delegator Address in MsgCreateValidator is deprecated. The validator address bytes and delegator address bytes refer to the same account while creating validator (defer only in bech32 notation)."
        },
        "validatorAddress": {
          "type": "string"
        },
        "pubkey": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object"
        },
        "value": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Validator",
      "description": "MsgCreateValidator defines a SDK message for creating a new validator."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    },
    "cosmos.staking.v1beta1.CommissionRates": {
      "properties": {
        "rate": {
          "type": "string",
          "description": "rate is the commission rate charged to delegators, as a fraction."
        },
        "maxRate": {
          "type": "string",
          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
        },
        "maxChangeRate": {
          "type": "string",
          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Commission Rates",
      "description": "CommissionRates defines the initial commission rates to be used for creating a validator."
    },
    "cosmos.staking.v1beta1.Description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": "moniker defines a human-readable name for the validator."
        },
        "identity": {
          "type": "string",
          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
        },
        "website": {
          "type": "string",
          "description": "website defines an optional website link."
        },
        "securityContact": {
          "type": "string",
          "description": "security_contact defines an optional email for security contact."
        },
        "details": {
          "type": "string",
          "description": "details define other optional details."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Description",
      "description": "Description defines a validator description."
    }
  }
}
,{
  "$ref": "#/definitions/MsgDelegate",
  "definitions": {
    "MsgDelegate": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        },
        "amount": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Delegate",
      "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgEditValidator",
  "definitions": {
    "MsgEditValidator": {
      "properties": {
        "description": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
          "additionalProperties": false
        },
        "validatorAddress": {
          "type": "string"
        },
        "commissionRate": {
          "type": "string",
          "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373"
        },
        "minSelfDelegation": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Edit Validator",
      "description": "MsgEditValidator defines a SDK message for editing an existing validator."
    },
    "cosmos.staking.v1beta1.Description": {
      "properties": {
        "moniker": {
          "type": "string",
          "description": "moniker defines a human-readable name for the validator."
        },
        "identity": {
          "type": "string",
          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
        },
        "website": {
          "type": "string",
          "description": "website defines an optional website link."
        },
        "securityContact": {
          "type": "string",
          "description": "security_contact defines an optional email for security contact."
        },
        "details": {
          "type": "string",
          "description": "details define other optional details."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Description",
      "description": "Description defines a validator description."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUndelegate",
  "definitions": {
    "MsgUndelegate": {
      "properties": {
        "delegatorAddress": {
          "type": "string"
        },
        "validatorAddress": {
          "type": "string"
        },
        "amount": {
          "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Undelegate",
      "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgUpdateParams",
  "definitions": {
    "MsgUpdateParams": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "params": {
          "$ref": "#/definitions/cosmos.staking.v1beta1.Params",
          "additionalProperties": false,
          "description": "params defines the x/staking parameters to update. NOTE: All parameters must be supplied."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Update Params",
      "description": "MsgUpdateParams is the Msg/UpdateParams request type."
    },
    "cosmos.staking.v1beta1.Params": {
      "properties": {
        "unbondingTime": {
          "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
          "type": "string",
          "description": "unbonding_time is the time duration of unbonding.",
          "format": "regex"
        },
        "maxValidators": {
          "type": "integer",
          "description": "max_validators is the maximum number of validators."
        },
        "maxEntries": {
          "type": "integer",
          "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."
        },
        "historicalEntries": {
          "type": "integer",
          "description": "historical_entries is the number of historical entries to persist."
        },
        "bondDenom": {
          "type": "string",
          "description": "bond_denom defines the bondable coin denomination."
        },
        "minCommissionRate": {
          "type": "string",
          "description": "min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Params",
      "description": "Params defines the parameters for the x/staking module."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCancelUpgrade",
  "definitions": {
    "MsgCancelUpgrade": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Cancel Upgrade",
      "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type."
    }
  }
}
,{
  "$ref": "#/definitions/MsgSoftwareUpgrade",
  "definitions": {
    "MsgSoftwareUpgrade": {
      "properties": {
        "authority": {
          "type": "string",
          "description": "authority is the address that controls the module (defaults to x/gov unless overwritten)."
        },
        "plan": {
          "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
          "additionalProperties": false,
          "description": "plan is the upgrade plan."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Software Upgrade",
      "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type."
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit."
        },
        "time": {
          "type": "string",
          "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
          "format": "date-time"
        },
        "height": {
          "type": "string",
          "description": "The height at which the upgrade must be performed."
        },
        "info": {
          "type": "string",
          "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to"
        },
        "upgradedClientState": {
          "properties": {
            "typeUrl": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
            }
          },
          "additionalProperties": true,
          "type": "object",
          "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Plan",
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreatePeriodicVestingAccount",
  "definitions": {
    "MsgCreatePeriodicVestingAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "startTime": {
          "type": "string",
          "description": "start of vesting as unix time (in seconds)."
        },
        "vestingPeriods": {
          "items": {
            "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Periodic Vesting Account",
      "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    },
    "cosmos.vesting.v1beta1.Period": {
      "properties": {
        "length": {
          "type": "string",
          "description": "Period duration in seconds."
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Period",
      "description": "Period defines a length of time and amount of coins that will vest."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreatePermanentLockedAccount",
  "definitions": {
    "MsgCreatePermanentLockedAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Permanent Locked Account",
      "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
,{
  "$ref": "#/definitions/MsgCreateVestingAccount",
  "definitions": {
    "MsgCreateVestingAccount": {
      "properties": {
        "fromAddress": {
          "type": "string"
        },
        "toAddress": {
          "type": "string"
        },
        "amount": {
          "items": {
            "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
          },
          "additionalProperties": false,
          "type": "array"
        },
        "endTime": {
          "type": "string",
          "description": "end of vesting as unix time (in seconds)."
        },
        "delayed": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Msg Create Vesting Account",
      "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account."
    },
    "cosmos.base.v1beta1.Coin": {
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "title": "Coin",
      "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto."
    }
  }
}
]
